<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2025-03-12" />
  <title>discrete_gauge_theory.tikzimg</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for citations */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
      margin-bottom: 0em;
    }
    .hanging-indent div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }  </style>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Libre+Baskerville&family=Quattrocento:wght@400">
  <style>
  body {
    font-family: Baskerville, 'Libre Baskerville', serif;
  }
  h1, h2, h3, h4, h5, h6, .abstract-title {
    font-family: Quattrocento, sans-serif;
    font-weight: bold;
    text-align: center;
  }
  img {
    display: block;
    margin-left: auto;
    margin-right: auto;
  }
  </style>
  <p><span class="math inline">\(\newcommand{\textesh}{∫}\)</span> <span class="math inline">\(\newcommand{\ensuremath}{}\)</span></p>
  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#abstract" id="toc-abstract">Abstract</a></li>
<li><a href="#overview" id="toc-overview"><span class="toc-section-number">1</span> Overview</a>
<ul>
<li><a href="#future-work" id="toc-future-work"><span class="toc-section-number">1.1</span> Future work</a></li>
</ul></li>
<li><a href="#torsors-and-principal-bundles" id="toc-torsors-and-principal-bundles"><span class="toc-section-number">2</span> Torsors and principal bundles</a>
<ul>
<li><a href="#torsors" id="toc-torsors"><span class="toc-section-number">2.1</span> Torsors</a></li>
<li><a href="#bundles-of-mere-circles" id="toc-bundles-of-mere-circles"><span class="toc-section-number">2.2</span> Bundles of mere circles</a></li>
<li><a href="#sec:pathovers" id="toc-sec:pathovers"><span class="toc-section-number">2.3</span> Pathovers in circle bundles</a></li>
</ul></li>
<li><a href="#discrete-manifolds" id="toc-discrete-manifolds"><span class="toc-section-number">3</span> Discrete manifolds</a>
<ul>
<li><a href="#abstract-simplicial-complexes" id="toc-abstract-simplicial-complexes"><span class="toc-section-number">3.1</span> Abstract simplicial complexes</a></li>
<li><a href="#higher-inductive-combinatorial-manifolds" id="toc-higher-inductive-combinatorial-manifolds"><span class="toc-section-number">3.2</span> Higher inductive combinatorial manifolds</a></li>
<li><a href="#sec:polygons" id="toc-sec:polygons"><span class="toc-section-number">3.3</span> Polygons</a></li>
<li><a href="#the-octahedron-model-of-the-sphere" id="toc-the-octahedron-model-of-the-sphere"><span class="toc-section-number">3.4</span> The octahedron model of the sphere</a></li>
</ul></li>
<li><a href="#bundles-connections-and-curvature" id="toc-bundles-connections-and-curvature"><span class="toc-section-number">4</span> Bundles, connections, and curvature</a>
<ul>
<li><a href="#definitions" id="toc-definitions"><span class="toc-section-number">4.1</span> Definitions</a></li>
<li><a href="#connections-as-local-trivializations" id="toc-connections-as-local-trivializations"><span class="toc-section-number">4.2</span> Connections as local trivializations</a></li>
<li><a href="#the-tangent-bundle-of-the-sphere" id="toc-the-tangent-bundle-of-the-sphere"><span class="toc-section-number">4.3</span> The tangent bundle of the sphere</a></li>
<li><a href="#existence-of-connections" id="toc-existence-of-connections"><span class="toc-section-number">4.4</span> Existence of connections</a></li>
</ul></li>
<li><a href="#vector-fields" id="toc-vector-fields"><span class="toc-section-number">5</span> Vector fields</a>
<ul>
<li><a href="#definition" id="toc-definition"><span class="toc-section-number">5.1</span> Definition</a></li>
<li><a href="#swirling" id="toc-swirling"><span class="toc-section-number">5.2</span> Swirling</a></li>
</ul></li>
<li><a href="#total-constructions" id="toc-total-constructions"><span class="toc-section-number">6</span> Total constructions</a>
<ul>
<li><a href="#total-holonomy" id="toc-total-holonomy"><span class="toc-section-number">6.1</span> Total holonomy</a></li>
<li><a href="#total-index-of-a-vector-field" id="toc-total-index-of-a-vector-field"><span class="toc-section-number">6.2</span> Total index of a vector field</a></li>
<li><a href="#the-main-theorem" id="toc-the-main-theorem"><span class="toc-section-number">6.3</span> The main theorem</a></li>
</ul></li>
<li><a href="#appendix" id="toc-appendix">Appendix</a></li>
</ul>
</nav>
<h1 class="unnumbered" id="abstract">Abstract</h1>
<p>Higher inductive types can capture some concepts of differential geometry in two dimensions including connections, curvature, and vector fields. We define connections on higher inductive types. We then define tangent bundles and vector fields by looking at the special subclass of combinatorial manifolds, which are discrete in the sense of real cohesion<span class="citation" data-cites="shulman_cohesion"> (<a href="#ref-shulman_cohesion" role="doc-biblioref">Shulman, 2017</a>)</span>, drawing inspiration from the field of discrete differential geometry. We prove the Gauss-Bonnet theorem and Poincaré-Hopf theorem for combinatorial manifolds.</p>
<p><em></em></p>
<p>This thesis is dedicated to John Baez, Sean M. Carroll, Sabine Hossenfelder, and other communicators who are carrying the torch of science forward in the spirit of my hero Carl Sagan. I have followed you all for many years, and you have inspired me to continue my studies alongside my unrelated career. Thank you.</p>
<blockquote>
<p>“It is always ourselves we work on, whether we realize it or not. There is no other work to be done in the world.” — Stephen Talbott, <em>The Future Does Not Compute</em><span class="citation" data-cites="talbott"> (<a href="#ref-talbott" role="doc-biblioref">Talbott, 1995</a>)</span></p>
</blockquote>
<h1 data-number="1" id="overview"><span class="header-section-number">1</span> Overview</h1>
<p>We will define</p>
<ul>
<li><p>combinatorial 2-manifolds</p></li>
<li><p>circle bundles, and principal circle bundles of tangent bundles</p></li>
<li><p>vector fields,</p></li>
</ul>
<p>and then observe emerging from those definitions the presence of</p>
<ul>
<li><p>connections</p></li>
<li><p>curvature</p></li>
<li><p>the index of a vector field,</p></li>
</ul>
<p>and attempt to prove</p>
<ul>
<li><p>the Gauss-Bonnet theorem</p></li>
<li><p>and the Poincaré-Hopf theorem.</p></li>
</ul>
<p>We will consider functions <span class="math inline">\(M\to \mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span> where <span class="math inline">\(\mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span> is the connected component in the universe of the Eilenberg-MacLane space <span class="math inline">\(\mathrm{K}(\ensuremath{\mathbb{Z}},1)\)</span> which we will take to be <span class="math inline">\(S^1\)</span>, and where <span class="math inline">\(M\)</span> is a combinatorial manifold of dimension 2, which is a simplicial complex encoded in a higher inductive type, such that each vertex has a neighborhood that looks like a disk with a discrete circle boundary (i.e. a polygon). We can call terms <span class="math inline">\(C:\mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span> “mere circles.”</p>
<p>We will see in Section <a href="#sec:polygons" data-reference-type="ref" data-reference="sec:polygons">3.3</a> that <span class="math inline">\(\mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span> contains all the polygons. We will construct a map <span class="math inline">\(\mathop{\mathrm{\mathsf{link}}}:M\to\mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span> that maps each vertex to the polygon consisting of its neighbors. Then we can consider the type of pointed mere circles <span class="math inline">\(\mathrm{EM_{\bullet}}(\ensuremath{\mathbb{Z}},1)\stackrel{\mathrm{def}}{=}\sum_{Y:\mathrm{EM}(\ensuremath{\mathbb{Z}},1)}Y\)</span> as well as the first projection that forgets the point. This is a univalent fibration (univalent fibrations are always equivalent to a projection of a type of pointed types to some connected component of the universe<span class="citation" data-cites="christensen_univalence"> (<a href="#ref-christensen_univalence" role="doc-biblioref">Christensen, 2015</a>)</span>). If we form the pullback</p>
<p><img src="./9c97f36dc8322034bc4869643bffe6cfd8a5fa50.svg" alt="image" /></p>
<p>then we have a bundle of mere circles, with total space given by the <span class="math inline">\(\sum_{}\)</span>-type construction. We will show that this is not a principal bundle, i.e. a bundle of torsors. Torsors are types with the additional structure of a group action. But if <span class="math inline">\(\mathop{\mathrm{\mathsf{link}}}\)</span> satisfies an additional property (amounting to an orientation) then the pullback is a principal fibration, i.e. <span class="math inline">\(\mathop{\mathrm{\mathsf{link}}}\)</span> factors through a map <span class="math inline">\(\mathrm{K}(\ensuremath{\mathbb{Z}},2)\to\mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span>, where <span class="math inline">\(\mathrm{K}(\ensuremath{\mathbb{Z}},2)\)</span> is an Eilenberg-Mac Lane space.</p>
<p>We will argue that extending <span class="math inline">\(\mathop{\mathrm{\mathsf{link}}}\)</span> to a function <span class="math inline">\(T\)</span> on paths can be thought of as constructing a connection, notably one that is not necessarily flat (trivial). Moreover, lifting <span class="math inline">\(T\)</span> to <span class="math inline">\(T_\bullet:M\to\mathrm{EM_{\bullet}}(\ensuremath{\mathbb{Z}},1)\)</span> can be thought of as a nonvanishing vector field. There will in general not be a total lift, just a partial function. The domain of <span class="math inline">\(T_\bullet\)</span> will have a boundary of circles, and the degree (winding number) on the disjoint union of these can be thought of as the index of <span class="math inline">\(T_\bullet\)</span>. We can then examine the total curvature and the total index and prove that they are equal, and argue that they are equal to the usual Euler characteristic. This will simultaneously prove the Poincaré-Hopf theorem and Gauss-Bonnet theorem in 2 dimensions, for combinatorial manifolds. This is similar to the classical proof of Hopf<span class="citation" data-cites="hopf"> (<a href="#ref-hopf" role="doc-biblioref">Hopf, 1983</a>)</span>, presented in detail in Needham<span class="citation" data-cites="needham"> (<a href="#ref-needham" role="doc-biblioref">Needham, 2021</a>)</span>.</p>
<h2 data-number="1.1" id="future-work"><span class="header-section-number">1.1</span> Future work</h2>
<p>The results of this note can be extended in many directions. There are higher-dimensional generalizations of Gauss-Bonnet, including the theory of characteristic classes and Chern-Weil theory (which links characteristic classes to connections and curvature). These would involve working with nonabelian groups like <span class="math inline">\(SO(n)\)</span> and sphere bundles. Results from gauge theory could be imported into HoTT, as well as results from surgery theory and other topological constructions that may be especially amenable to this discrete setting. Relationships with computer graphics and discrete differential geometry<span class="citation" data-cites="crane_ddg"> (<a href="#ref-crane_ddg" role="doc-biblioref">Crane <em>et al.</em>, 2013</a>)</span><span class="citation" data-cites="crane_connections"> (<a href="#ref-crane_connections" role="doc-biblioref">Crane, 2010</a>)</span> could be explored. Finally, a theory that reintroduces smoothness could allow more formal versions of the analogies explored here.</p>
<h1 data-number="2" id="torsors-and-principal-bundles"><span class="header-section-number">2</span> Torsors and principal bundles</h1>
<p>The classical theory of principal bundles tells us to look for an appropriate classifying space of torsors to map into.</p>
<h2 data-number="2.1" id="torsors"><span class="header-section-number">2.1</span> Torsors</h2>
<div class="mydef">
<p><strong>Definition 1</strong>. <em>Let <span class="math inline">\(G\)</span> be a group with identity element <span class="math inline">\(e\)</span> (with the usual classical structure and properties). A <strong><span class="math inline">\(G\)</span>-set</strong> is a set <span class="math inline">\(X\)</span> equipped with a homomorphism <span class="math inline">\(\phi:(G,e)\to\mathop{\mathrm{Aut}}(X)\)</span>. If in addition we have a term <span class="math display">\[\mathsf{is\_torsor}:||X||_{-1}\times \prod_{x:X}\mathsf{is\_equiv}(\phi(-,x):(G,e)\to (X,x))\]</span> then we call this data a <strong><span class="math inline">\(G\)</span>-torsor</strong>. Denote the type of <span class="math inline">\(G\)</span>-torsors by <span class="math inline">\(BG\)</span>.</em></p>
</div>
<p>If <span class="math inline">\((X,\phi),(Y,\psi):BG\)</span> then a <span class="math inline">\(G\)</span>-equivariant map is a function <span class="math inline">\(f:X\to Y\)</span> such that <span class="math inline">\(f(\phi(g,x))=\psi(g,f(x))\)</span>. Denote the type of <span class="math inline">\(G\)</span>-equivariant maps by <span class="math inline">\(X\to_G Y\)</span>.</p>
<div class="mylemma">
<p><strong>Lemma 2</strong>. <em>There is a natural equivalence <span class="math inline">\((X=_{BG}Y) \simeq (X\to_G Y)\)</span>.0◻</em></p>
</div>
<p>Denote by <span class="math inline">\(*\)</span> the torsor given by <span class="math inline">\(G\)</span> actions on its underlying set by left-translation. This serves as a basepoint for <span class="math inline">\(BG\)</span> and we have a group isomorphism <span class="math inline">\(\Omega BG\simeq G\)</span>.</p>
<div class="mylemma">
<p><strong>Lemma 3</strong>. <em>A <span class="math inline">\(G\)</span>-set <span class="math inline">\((X,\phi)\)</span> is a <span class="math inline">\(G\)</span>-torsor if and only if there merely exists a <span class="math inline">\(G\)</span>-equivariant equivalence <span class="math inline">\(*\to_G X\)</span>.0◻</em></p>
</div>
<div class="mycor">
<p><strong>Corollary 4</strong>. <em>The pointed type <span class="math inline">\((BG,*)\)</span> is a <span class="math inline">\(\mathrm{K}(G,1)\)</span>.0◻</em></p>
</div>
<p>In particular, to classify principal <span class="math inline">\(S^1\)</span>-bundles we map into the space <span class="math inline">\(\mathrm{K}(S^1, 1)\)</span>, a type of torsors of the circle. Since <span class="math inline">\(S^1\)</span> is a <span class="math inline">\(\mathrm{K}(\ensuremath{\mathbb{Z}},1)\)</span>, we have <span class="math inline">\(\mathrm{K}(S^1,1)\simeq\mathrm{K}(\ensuremath{\mathbb{Z}},2)\)</span>.</p>
<h2 data-number="2.2" id="bundles-of-mere-circles"><span class="header-section-number">2.2</span> Bundles of mere circles</h2>
<p>We find it illuminating to look also at the slightly more general classifying space of <span class="math inline">\(\mathrm{K}(\ensuremath{\mathbb{Z}},1)\)</span>-bundles, that is bundles whose fiber are equivalent to <span class="math inline">\(\mathrm{K}(\ensuremath{\mathbb{Z}},1)\)</span>. We can understand very well when these are in fact bundles of circle torsors, which will in turn shed light on orientation in this setting.</p>
<p>We will follow Scoccola<span class="citation" data-cites="sco"> (<a href="#ref-sco" role="doc-biblioref">Scoccola, 2020</a>)</span>. We will state the definitions and theorems for a general <span class="math inline">\(\mathrm{K}(G,n)\)</span> but we will be focusing on <span class="math inline">\(n=1\)</span> in this note.</p>
<div class="mydef">
<p><strong>Definition 5</strong>. <em>Let <span class="math inline">\(\mathrm{EM}(G,n)\stackrel{\mathrm{def}}{=}\mathop{\mathrm{BAut}}(\mathrm{K}(G,n))\stackrel{\mathrm{def}}{=}\sum_{Y:\mathcal{U}}||Y\simeq \mathrm{K}(G,n)||_{-1}\)</span>. A <strong><span class="math inline">\(\mathrm{K}(G,n)\)</span>-bundle</strong> on a type <span class="math inline">\(M\)</span> is the fiber of a map <span class="math inline">\(M\to\mathrm{EM}(G,n)\)</span>.</em></p>
</div>
<p>Scoccola uses two self-maps on the universe: suspension followed by <span class="math inline">\((n+1)\)</span>-truncation <span class="math inline">\(||\Sigma||_{n+1}\)</span> and forgetting a point <span class="math inline">\(F_\bullet\)</span> to form the composition <span class="math display">\[\mathrm{EM}(G,n)\xrightarrow[]{||\Sigma||_{n+1}} \mathrm{EM}_{\bullet\bullet}(G,n+1)\xrightarrow[]{F_\bullet}\mathrm{EM_{\bullet}}(G,n+1)\]</span> from types to types with two points (north and south), to pointed types (by forgetting the south point).</p>
<div class="mydef">
<p><strong>Definition 6</strong>. <em>Given <span class="math inline">\(f:M\to\mathrm{EM}(G,n)\)</span>, the <strong>associated action of <span class="math inline">\(M\)</span> on <span class="math inline">\(G\)</span></strong>, denoted by <span class="math inline">\(f_\bullet\)</span> is defined to be <span class="math inline">\(f_\bullet=F_\bullet\circ||\Sigma||_{n+1}\circ f\)</span>.</em></p>
</div>
<div class="mythm">
<p><strong>Theorem 7</strong>. <em>(Scoccola<span class="citation" data-cites="sco"> (<a href="#ref-sco" role="doc-biblioref">Scoccola, 2020</a>)</span> Proposition 2.39). A <span class="math inline">\(\mathrm{K}(G,n)\)</span> bundle <span class="math inline">\(f:M\to\mathrm{EM}(G,n)\)</span> is equivalent to a map in <span class="math inline">\(M\to\mathrm{K}(G,n+1)\)</span>, and so is a principal fibration, if and only if the associated action <span class="math inline">\(f_\bullet\)</span> is contractible.</em></p>
</div>
<p>Let’s relate this to <em>orientation</em>. Note that the obstruction in the theorem is about a map into <span class="math inline">\(\mathrm{EM_{\bullet}}(G,n+1)\)</span> and further note that <span class="math inline">\(\mathrm{EM_{\bullet}}(G,n)\simeq \mathrm{K}(\mathop{\mathrm{Aut}}G,1)\)</span> (independent of <span class="math inline">\(n\)</span>). The theorem says that the data of a map into <span class="math inline">\(\mathrm{EM}(G,n)\)</span> factors into data about a map into <span class="math inline">\(\mathrm{K}(G,n+1)\)</span> and one into <span class="math inline">\(\mathrm{K}(\mathop{\mathrm{Aut}}G,1)\)</span>. Informally, <span class="math inline">\(\mathrm{EM}(G,n)\)</span> is a little too large to be a <span class="math inline">\(K(G,n+1)\)</span>, as it includes data about automorphisms of <span class="math inline">\(G\)</span>.</p>
<p>In the special case of <span class="math inline">\(\mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span> the conditions of the theorem are met when <span class="math inline">\(f_\bullet:M\to\mathrm{K}(\mathop{\mathrm{Aut}}\ensuremath{\mathbb{Z}}, 1)\)</span> is contractible. <span class="math inline">\(\mathop{\mathrm{Aut}}\ensuremath{\mathbb{Z}}\)</span> consists of the <span class="math inline">\(\ensuremath{\mathbb{Z}}/2\ensuremath{\mathbb{Z}}\)</span> worth of outer automorphisms given by multiplication by <span class="math inline">\(\pm 1\)</span>. If we look at the fiber sequence <span class="math display">\[\mathrm{K}(S^1, 1)\to \mathop{\mathrm{BAut}}S^1\to \mathrm{K}(\mathop{\mathrm{Aut}}\ensuremath{\mathbb{Z}}, 1)\]</span> we see the automorphisms of the circle as an extension of the group of automorphisms that are homotopic to the identity (which are the torsorial actions) by the group that sends the loop in <span class="math inline">\(S^1\)</span> to its inverse. This is another way to see that a map <span class="math inline">\(f:M\to \mathop{\mathrm{BAut}}S^1\simeq \mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span> factors through <span class="math inline">\(\mathrm{K}(S^1, 1)\simeq \mathrm{K}(\ensuremath{\mathbb{Z}},2)\)</span> if and only if the composition to <span class="math inline">\(\mathrm{K}(\mathop{\mathrm{Aut}}\ensuremath{\mathbb{Z}},1)\)</span> is trivial. This amounts to a choice of loop-direction for all the circles, and so deserves the name “<span class="math inline">\(f\)</span> is <em>oriented</em>.” In addition the map <span class="math inline">\(\mathop{\mathrm{BAut}}S^1\to \mathrm{K}(\mathop{\mathrm{Aut}}\ensuremath{\mathbb{Z}}, 1)\)</span> deserves to be called the first Stiefel-Whitney class of <span class="math inline">\(f\)</span>, and the requirement here is that it vanishes. This point of view is discussed in Schreiber<span class="citation" data-cites="dcct"> (<a href="#ref-dcct" role="doc-biblioref">Schreiber, 2013</a>)</span> (starting with Example 1.2.138) and in Myers<span class="citation" data-cites="myersgood"> (<a href="#ref-myersgood" role="doc-biblioref">Myers, 2022</a>)</span>.</p>
<div class="mynote">
<p><strong>Remark 8</strong>. <em>Bundles of oriented mere circles are principal, but this fact does not hold for bundles of higher-dimensional spheres. Since this note will focus on 2-dimensional oriented manifolds we will be making use of this coincidence.</em></p>
</div>
<h2 data-number="2.3" id="sec:pathovers"><span class="header-section-number">2.3</span> Pathovers in circle bundles</h2>
<p>Suppose we have <span class="math inline">\(T:M\to\mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span> and <span class="math inline">\(P\stackrel{\mathrm{def}}{=}\sum_{x:M}T(x)\)</span>. We adopt a convention of naming objects in <span class="math inline">\(M\)</span> with Latin letters, and the corresponding structures in <span class="math inline">\(P\)</span> with Greek letters. Recall that if <span class="math inline">\(p:a=_M b\)</span> then <span class="math inline">\(T\)</span> acts on <span class="math inline">\(p\)</span> with what’s called the <em>action on paths</em>, denoted <span class="math inline">\(\ensuremath{\mathsf{ap}}(T)(p):T(a)=T(b)\)</span>. This is a path in the codomain, which in this case is a type of types. Type theory also provides a function called <em>transport</em>, denoted <span class="math inline">\(\mathsf{tr}(p):T(a)\to T(b)\)</span> which acts on the fibers of <span class="math inline">\(P\)</span>. <span class="math inline">\(\mathsf{tr}(p)\)</span> is a function, acting on the terms of the types <span class="math inline">\(T(a)\)</span> and <span class="math inline">\(T(b)\)</span>, and univalence tells us this is the isomorphism corresponding to <span class="math inline">\(\ensuremath{\mathsf{ap}}(T)(p)\)</span>.</p>
<p>Type theory also tells us that paths in <span class="math inline">\(P\)</span> are given by pairs of paths: a path <span class="math inline">\(p:a=_M b\)</span> in the base, and a pathover <span class="math inline">\(\pi:\mathsf{tr}(p)(\alpha)=_{T(b)}\beta\)</span> between <span class="math inline">\(\alpha:T(a)\)</span> and <span class="math inline">\(\beta:T(b)\)</span> in the fibers. We can’t directly compare <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> since they are of different types, so we apply transport to one of them. We say <span class="math inline">\(\pi\)</span> lies over <span class="math inline">\(p\)</span>. See Figure <a href="#fig:pathovers" data-reference-type="ref" data-reference="fig:pathovers">1</a>.</p>
<figure id="fig:pathovers">
<embed src="figs/pathovers.pdf" style="width:2.77778in" />
<figcaption>A path <span class="math inline">\(\pi\)</span> over the path <span class="math inline">\(p\)</span> in the base involves the transport function.</figcaption>
</figure>
<p>Lastly we want to recall that in the presence of a section <span class="math inline">\(X:M\to P\)</span> there is a dependent generalization of <span class="math inline">\(\ensuremath{\mathsf{ap}}\)</span> called <span class="math inline">\(\mathsf{apd}\)</span>: <span class="math inline">\(\mathsf{apd}(X)(p):\mathsf{tr}(p)(X(a))=X(b)\)</span> which is a pathover between the two values of the section over the basepoints of the path <span class="math inline">\(p\)</span>.</p>
<h1 data-number="3" id="discrete-manifolds"><span class="header-section-number">3</span> Discrete manifolds</h1>
<p>We will remind ourselves of the definition of a classical simplicial complex, in sets. Then we will create a higher type from the data of a complex, using pushouts. The type will both imitate the structure of the set-based complex and will contain explicit maps into it from the sets of the complex.</p>
<h2 data-number="3.1" id="abstract-simplicial-complexes"><span class="header-section-number">3.1</span> Abstract simplicial complexes</h2>
<div class="mydef">
<p><strong>Definition 9</strong>. <em>An <strong>abstract simplicial complex <span class="math inline">\(M\stackrel{\mathrm{def}}{=}[M_0,\ldots,M_n]\)</span> of dimension <span class="math inline">\(n\)</span></strong> is an ordered list consisting of a set <span class="math inline">\(M_0\)</span> of vertices, and for each <span class="math inline">\(0&lt;k\leq n\)</span> a set <span class="math inline">\(M_k\)</span> of subsets of <span class="math inline">\(M_0\)</span> of cardinality <span class="math inline">\(k+1\)</span>, such that any <span class="math inline">\((j+1)\)</span>-element subset of <span class="math inline">\(M_k\)</span> is an element of <span class="math inline">\(M_j\)</span>. The elements of <span class="math inline">\(M_k\)</span> are called <strong><span class="math inline">\(k\)</span>-faces</strong>. Denote by <span class="math inline">\(\mathsf{SimpCompSet_n}\)</span> the type of abstract simplicial complexes of dimension <span class="math inline">\(n\)</span> (where the suffix <span class="math inline">\(\mathsf{Set}\)</span> reminds us that this is a type of sets). Let <span class="math inline">\(M_{\leq k}= [M_0,\ldots,M_k]\)</span> and note that <span class="math inline">\(M_{\leq n}=M\)</span>. We call <span class="math inline">\(M_{\leq k}\)</span> the <strong><span class="math inline">\(k\)</span>-skeleton</strong> of <span class="math inline">\(M\)</span>, and it is a (<span class="math inline">\(k\)</span>-)complex in its own right. <span class="math inline">\(M\)</span> is automatically equipped with a chain of inclusions of the skeleta <span class="math inline">\(M_0\hookrightarrow M_{\leq 1}\hookrightarrow\cdots\hookrightarrow M_{\leq n}=M\)</span>. A <strong>morphism</strong> <span class="math inline">\(f\)</span> from <span class="math inline">\(M=[M_0,\ldots,M_m]\)</span> to <span class="math inline">\(N=[N_0,\ldots,N_n]\)</span> is a function on vertices <span class="math inline">\(f:M_0\to N_0\)</span> such that for any face of <span class="math inline">\(M\)</span> the image under <span class="math inline">\(f\)</span> is a face of <span class="math inline">\(N\)</span>.</em></p>
</div>
<div class="mydef">
<p><strong>Definition 10</strong>. <em>Let <span class="math inline">\(\Delta^n\)</span> be the standard <span class="math inline">\(n\)</span>-simplex in <span class="math inline">\(\ensuremath{\mathbb{R}}^n\)</span> given by <span class="math inline">\(\{x_1,\ldots,x_n|\sum_i x_i\leq 1\}\)</span>. Let <span class="math inline">\(M:\mathsf{SimpCompSet_n}\)</span>. The <strong>geometric realization</strong> <span class="math inline">\([{M}]:\mathsf{Top}\)</span> of <span class="math inline">\(M\)</span> in the category of topological spaces is given inductively as follows: <span class="math inline">\([M_0]=M_0\)</span>, and given <span class="math inline">\([M_{\leq k-1}]\)</span> we form <span class="math inline">\([M_{\leq k}]\)</span> by the pushout in sets</em></p>
</div>
<p><img src="./5f850668df693060e5d39dd1a2a43ad51b673e1e.svg" alt="image" /></p>
<p>which attaches each <span class="math inline">\(k\)</span>-simplex by taking the convex hull of the appropriate <span class="math inline">\(k+1\)</span> points in <span class="math inline">\([M_{\leq k-1}]\)</span>. The collection of vertical maps on the right gives a sequence of inclusion maps of skeleta <span class="math inline">\([M_0]\xrightarrow[]{i_1}[M_{\leq 1}]\xrightarrow[]{i_2}\cdots\xrightarrow[]{i_n}[M_{\leq n}]=[{M}]\)</span>.</p>
<div id="def:link" class="mydef">
<p><strong>Definition 11</strong>. <em>In an abstract simplicial complex <span class="math inline">\(M\)</span> of dimension <span class="math inline">\(n\)</span>, the <strong>link</strong> of a vertex <span class="math inline">\(v\)</span> is the <span class="math inline">\(n-1\)</span>-dimensional subcomplex containing every face <span class="math inline">\(m\in M_{n-1}\)</span> such that <span class="math inline">\(v\notin m\)</span> and <span class="math inline">\(m\cup v\)</span> is an <span class="math inline">\(n\)</span>-face of <span class="math inline">\(M\)</span>. </em></p>
</div>
<p>The link is easier to understand as all the neighboring vertices of <span class="math inline">\(v\)</span> and the subcomplex containing these. See for example Figure <a href="#fig:link" data-reference-type="ref" data-reference="fig:link">2</a>.</p>
<figure id="fig:link">
<img src="./77310e6013360f123738b3984e7a97ecabc90011.svg" />
<figcaption>The link of <span class="math inline">\(v\)</span> in this complex consists of the vertices <span class="math inline">\(\{a,b,c,d,e,f\}\)</span> and the edges <span class="math inline">\(\{ab,bc,cd,de,ef,fa\}\)</span>, forming a hexagon.</figcaption>
</figure>
<div class="mydef">
<p><strong>Definition 12</strong>. <em>A <strong>combinatorial manifold</strong> (or <strong>combinatorial triangulation</strong>) of dimension <span class="math inline">\(n\)</span> is a simplicial complex of dimension <span class="math inline">\(n\)</span> such that the link of every vertex is a <strong>simplicial sphere</strong> of dimension <span class="math inline">\(n-1\)</span> (meaning its geometric realization is homeomorphic to an <span class="math inline">\(n-1\)</span>-sphere). Denote by <span class="math inline">\(\mathsf{CombMfdSet_n}\)</span> the type of combinatorial manifolds of dimension <span class="math inline">\(n\)</span> (which the notation again reminds us are sets).</em></p>
</div>
<p>In a 2-dimensional combinatorial manifold the link is a polygon. See Figure <a href="#fig:sphere_triangulation" data-reference-type="ref" data-reference="fig:sphere_triangulation">3</a> for some examples of 2-dimensional combinatorial manifolds of genus 0, 1, and 3.</p>
<p>A classical 1940 result of Whitehead, building on Cairn, states that every smooth manifold admits a combinatorial triangulation<span class="citation" data-cites="whitehead_triangulation"> (<a href="#ref-whitehead_triangulation" role="doc-biblioref">Whitehead, 1940</a>)</span>. So it appears reasonably well motivated to study this class of objects. See for example the classic book by Kirby and Siebenmann<span class="citation" data-cites="kirby_siebenmann"> (<a href="#ref-kirby_siebenmann" role="doc-biblioref">Kirby &amp; Siebenmann, 1977</a>)</span>. There are important examples in four dimensions of topological manifolds that do not have any smoothness structure or triangulation. These will be out of reach of the theory we are building.</p>
<figure id="fig:sphere_triangulation">
<p><embed src="figs/triangulated_sphere.pdf" style="width:1.38889in" /> <img src="figs/Torus-triang.png" style="width:1.38889in" alt="image" /> <embed src="figs/triangulated_genus3.pdf" style="width:1.38889in" /></p>
<figcaption>Combinatorial triangulations of a sphere, torus, and 3-holed torus. Sphere created with the tool <code>stripy</code>; torus from Wikipedia (<a href="https://commons.wikimedia.org/w/index.php?curid=30856793">By Ag2gaeh</a> - Own work, CC BY-SA 3.0.); 3-holed torus from Wikipedia (<a href="https://commons.wikimedia.org/wiki/File:Tri-brezel.svg">By Ag2gaeh</a> - Own work, CC BY-SA 3.0.)</figcaption>
</figure>
<h2 data-number="3.2" id="higher-inductive-combinatorial-manifolds"><span class="header-section-number">3.2</span> Higher inductive combinatorial manifolds</h2>
<p>Instead of building a set <span class="math inline">\([{M}]:\mathsf{Top}\)</span>, we can realize the simplicial complex as a (higher) type by forming a sequence of <em>homotopy</em> pushouts. For example in dimension 1 we could take the triangle with vertices <span class="math inline">\(\{v_1, v_2, v_3\}\)</span> and edges <span class="math inline">\(\{e_{12}, e_{23}, e_{31}\}\)</span> and form a polygon <span class="math inline">\(C_3\)</span>:</p>
<p><img src="./fb70e8046f0ef3601a17feb7806703caf5425365.svg" alt="image" /></p>
<p>The left vertical map expresses the connectivity between the edges and vertices in the set-based complex. The right vertical map <span class="math inline">\(*_1\)</span> provides a hub point for each edge, and the homotopy <span class="math inline">\(h_1\)</span> provides the spokes that connect the hub to the vertices. So in contrast to a geometric realization, the 1-dimensional cells in the HoTT sense are generated by the filler homotopy.</p>
<p>In dimension 2 we could fill in maps from <span class="math inline">\(C_3\)</span> into our higher type by adding faces (hence reusing the object we just built above):</p>
<p><img src="./59159619e9738f2cedd3c95491c185b941b34336.svg" alt="image" /></p>
<p>The types <span class="math inline">\(C_3\)</span> and <span class="math inline">\(\ensuremath{\mathbb{M}}_1\)</span> are 1-types, <span class="math inline">\(\ensuremath{\mathbb{M}}_2\)</span> is a 2-type, and the rest are sets. The map <span class="math inline">\(\partial_0\)</span> maps each pair <span class="math inline">\((e, S^0)\)</span> to the pair of points this edge connects.</p>
<p>The <span class="math inline">\(h_i\)</span> are the proofs of commutativity, and the two squares are also both homotopy pushouts. Note that the pushouts could be re-expressed as HIT constructors.</p>
<p>Whereas in geometric realization we use both <span class="math inline">\(\Delta^i\)</span> and <span class="math inline">\(\partial\Delta^i\)</span> to attach simplices, in this homotopy picture we need an explicit construction of “<span class="math inline">\(\partial\Delta^i\)</span>” as a type equivalent to an <span class="math inline">\(i-1\)</span>-dimensional sphere and the filling of this sphere with <span class="math inline">\(i\)</span>-dimensional stuff has moved into the proof of commutativity. So in dimension <span class="math inline">\(n\)</span> the picture would be</p>
<p><img src="./060f84a40591ae2293f7dffd08753bc1ed0a2948.svg" alt="image" /></p>
<div id="def:higher_realization" class="mydef">
<p><strong>Definition 13</strong>. <em>A <strong>higher realization</strong> <span class="math inline">\([\![{M}]\!]\)</span> corresponding to an abstract simplicial complex <span class="math inline">\(M:\mathsf{SimpCompSet_n}\)</span> consists of</em></p>
<ol>
<li><p><em><span class="math inline">\(n+1\)</span> types <span class="math inline">\(\ensuremath{\mathbb{M}}_0,\ldots,\ensuremath{\mathbb{M}}_n\)</span> where <span class="math inline">\(\ensuremath{\mathbb{M}}_0\stackrel{\mathrm{def}}{=}M_0\)</span>,</em></p></li>
<li><p><em><span class="math inline">\(n\)</span> spans <span class="math inline">\({\ensuremath{\mathbb{M}}_{i}}\xleftarrow[]{\partial_{i}}{M_{i+1}\times S^{i}}\xrightarrow[]{\ensuremath{\mathrm{pr}}_1}{M_{i+1}}\)</span>, <span class="math inline">\(i=1,\ldots,n\)</span>, where <span class="math inline">\(S^i\)</span> is a HoTT <span class="math inline">\(i\)</span>-sphere and <span class="math inline">\(\partial_i\)</span> are called <strong>attachment maps</strong>,</em></p></li>
<li><p><em><span class="math inline">\(n\)</span> pushout squares from each span to <span class="math inline">\(\ensuremath{\mathbb{M}}_{i+1}\)</span>, with induced maps <span class="math inline">\(\imath_i:\ensuremath{\mathbb{M}}_i\to\ensuremath{\mathbb{M}}_{i+1}\)</span>, <span class="math inline">\(*_{i+1}:M_{i+1}\to\ensuremath{\mathbb{M}}_{i+1}\)</span> and proof of commutativity <span class="math inline">\(h_{i+1}\)</span>.</em></p></li>
</ol>
<p><em>We call the sequence <span class="math inline">\(\ensuremath{\mathbb{M}}_0\xrightarrow[]{\imath_0}\ensuremath{\mathbb{M}}_1\xrightarrow[]{\imath_1}\cdots\xrightarrow[]{\imath_{n-1}}\ensuremath{\mathbb{M}}_n\)</span>, together with a proof of existence of some <span class="math inline">\([\![{M}]\!]\)</span> inducing this sequence, a <strong>cellular type</strong>. We define forgetful maps to the bare types with <span class="math inline">\([\![{M}]\!]_i\stackrel{\mathrm{def}}{=}\ensuremath{\mathbb{M}}_i\)</span>.</em></p>
</div>
<p>We intend for the <span class="math inline">\(\partial_i\)</span> to be isomorphisms between a boundary of a simplex in <span class="math inline">\(\ensuremath{\mathbb{M}}_i\)</span> and the <span class="math inline">\(i\)</span>-sphere. To avoid spending too much time above dimension 2, we will leave the <span class="math inline">\(\partial_i\)</span> underspecified in general. For 2-dimensional complexes we will see how the gluing can be done for triangles.</p>
<h2 data-number="3.3" id="sec:polygons"><span class="header-section-number">3.3</span> Polygons</h2>
<p>Recall the 1-type <span class="math inline">\(C_3\)</span> that we just constructed from the triangle with vertex set <span class="math inline">\(\{v_1, v_2, v_3\}\)</span> and edge set <span class="math inline">\(\{e_{12}, e_{23}, e_{31}\}\)</span>:</p>
<p><img src="./fb70e8046f0ef3601a17feb7806703caf5425365.svg" alt="image" /></p>
<p>We will use a notational shorthand for polygons:</p>
<div class="mydef">
<p><strong>Definition 14</strong>. <em>If <span class="math inline">\(C_n\)</span> is a simplicial complex with <span class="math inline">\(C_{n,0}=\{v_1, \ldots, v_n\}\)</span> and edges <span class="math inline">\(e_1=\{v_1,v_2\},\ldots,e_{n-1}=\{v_{n-1}, v_n\}, e_n=\{v_n, v_0\}\)</span>, we call <span class="math inline">\(C_n\)</span> a <strong>polygon</strong> or <strong><span class="math inline">\(n\)</span>-gon</strong>. We can refer to <span class="math inline">\(C_n\)</span> by <span class="math inline">\(v_1 v_2\cdots v_n\)</span>, to <span class="math inline">\([{C_n}]\)</span> by <span class="math inline">\([{v_1 v_2\cdots v_n}]\)</span> and to <span class="math inline">\([\![{C_n}]\!]\)</span> by <span class="math inline">\([\![{v_1 v_2\cdots v_n}]\!]\)</span>. Forgetting the pushouts and vertices, we denote the bare 1-type by <span class="math inline">\([\![{v_1 v_2\cdots v_n}]\!]_1\)</span>.</em></p>
</div>
<p>We also have the special circle type that is not the realization of a simplicial complex, but is nevertheless the natural basepoint in the type of polygons, as we shall see:</p>
<div class="mydef">
<p><strong>Definition 15</strong>. <em>The higher inductive type <span class="math inline">\(S^1\)</span>, also denoted <span class="math inline">\([\![{C_1}]\!]_1\)</span> for convenience, despite <span class="math inline">\(C_1\)</span> not being a simplicial complex, has constructors: <span class="math display">\[\begin{aligned}
S^1&amp;:\mathsf{Type}\\
\mathsf{base}&amp;:S^1\\
\mathsf{loop}&amp;:\mathsf{base}=\mathsf{base}
\end{aligned}\]</span></em></p>
</div>
<div id="lem:addpoints" class="mylemma">
<p><strong>Lemma 16</strong>. <em><span class="math inline">\([\![{C_2}]\!]_1\simeq [\![{C_1}]\!]_1\)</span> and in fact <span class="math inline">\([\![{C_n}]\!]_1\simeq [\![{C_{n-1}}]\!]_1\)</span>.</em></p>
</div>
<p><em>Proof.</em> (Compare to <span class="citation" data-cites="hottbook"> (<a href="#ref-hottbook" role="doc-biblioref">Univalent Foundations Program, 2013</a>)</span> Lemma 6.5.1.) In the case of <span class="math inline">\([\![{C_1}]\!]_1\)</span> we will denote its constructors by <span class="math inline">\(\ensuremath{\mathsf{base}}\)</span> and <span class="math inline">\(\ensuremath{\mathsf{loop}}\)</span>. For <span class="math inline">\([\![{C_2}]\!]_1\)</span> we will denote the points by <span class="math inline">\(v_1, v_2\)</span> and the edges by <span class="math inline">\(\ell_{12}, r_{21}\)</span>. For <span class="math inline">\([\![{C_3}]\!]_1\)</span> and higher we will denote the points by <span class="math inline">\(v_1,\ldots,v_n\)</span> and the edges by <span class="math inline">\(e_{i,j}:v_i=v_j\)</span> where <span class="math inline">\(j=i+1\)</span> except for <span class="math inline">\(e_{n,1}\)</span>.</p>
<p>First we will define <span class="math inline">\(f:[\![{C_2}]\!]_1\to [\![{C_1}]\!]_1\)</span> and <span class="math inline">\(g:[\![{C_1}]\!]_1\to [\![{C_2}]\!]_1\)</span>, then prove they are inverses. <span class="math display">\[\begin{aligned}
f(v_1)=f(v_2)&amp;=\ensuremath{\mathsf{base}}&amp;\quad g(\ensuremath{\mathsf{base}})&amp;=v_1\\
f(\ell_{12})&amp;=\ensuremath{\mathsf{loop}}&amp;\quad g(\ensuremath{\mathsf{loop}})&amp;=\ell_{12}\cdot r_{21}\\
f(r_{21}) &amp;= \ensuremath{\mathsf{refl}}_{\ensuremath{\mathsf{base}}}&amp; &amp; \\
\end{aligned}\]</span></p>
<p>We need to show that <span class="math inline">\(f\circ g\sim \ensuremath{\text{id}}_{[\![{C_1}]\!]_1}\)</span> and <span class="math inline">\(g\circ f\sim\ensuremath{\text{id}}_{[\![{C_2}]\!]_1}\)</span>. Think of <span class="math inline">\(f\)</span> as sliding <span class="math inline">\(v_2\)</span> along <span class="math inline">\(r_{21}\)</span> to coalesce with <span class="math inline">\(v_1\)</span>. This may help understand why the unfortunately intricate proof is working.</p>
<p>Recall that given functions <span class="math inline">\(\phi,\psi:A\to B\)</span> between two arbitrary types we can form a type family of paths <span class="math inline">\(\alpha:A\to\mathcal{U}\)</span> by <span class="math inline">\(\alpha(a)\stackrel{\mathrm{def}}{=}(\phi(a)=_B\psi(a))\)</span>. Transport in this family is given by concatenation as follows, where <span class="math inline">\(p:a=_A a&#39;\)</span> and <span class="math inline">\(q:\phi(a)=\psi(a)\)</span> (see Figure <a href="#fig:transport_family_of_paths" data-reference-type="ref" data-reference="fig:transport_family_of_paths">4</a>): <span class="math display">\[\mathsf{tr}(p)(q) = \phi(p)^{-1}\cdot q\cdot \psi(p)\]</span> which gives a path in <span class="math inline">\(\phi(a&#39;)=\psi(a&#39;)\)</span> by connecting dots between the terms <span class="math inline">\(\phi(a&#39;), \phi(a), \psi(a), \psi(a&#39;)\)</span>. This relates a would-be homotopy <span class="math inline">\(\phi\sim\psi\)</span> specified at a single point, to a point at the end of a path. We will use this to help construct such homotopies.</p>
<figure id="fig:transport_family_of_paths">
<img src="./17fd332eed0d72f858e81f4722d8b1e5b33a5029.svg" />
<figcaption>Transport along <span class="math inline">\(p\)</span> in the fibers of a family of paths. The fiber over <span class="math inline">\(a\)</span> is <span class="math inline">\(\phi(a)=\psi(a)\)</span> where <span class="math inline">\(\phi,\psi:A\to B\)</span>.</figcaption>
</figure>
<p>We need terms <span class="math inline">\(p:\prod_{a:[\![{C_1}]\!]_1}f(g(a))=a\)</span> and <span class="math inline">\(q:\prod_{a:[\![{C_2}]\!]_1}g(f(a))=a\)</span>. We will proceed by induction, defining appropriate paths on point constructors and then checking a condition on path constructors that confirms that the built-in transport of these type families respects the definition on points.</p>
<p>Looking first at <span class="math inline">\(g\circ f\)</span>, which shrinks <span class="math inline">\(r_{21}\)</span>, we have the following data to work with: <span class="math display">\[\begin{aligned}
g(f(v_1))=g(f(v_2))&amp;=v_1\\
g(f(\ell_{12}))&amp;=\ell_{12}\cdot r_{21}\\
g(f(r_{21})) &amp;= \ensuremath{\mathsf{refl}}_{v_1}.
\end{aligned}\]</span> We then need to supply a homotopy from this data to <span class="math inline">\(\ensuremath{\text{id}}_{[\![{C_2}]\!]_1}\)</span>, which consists of a section and pathovers over <span class="math inline">\([\![{C_2}]\!]_1\)</span>: <span class="math display">\[\begin{aligned}
p_1&amp;:g(f(v_1))=v_1\\
p_2&amp;:g(f(v_1))=v_2\\
H_\ell&amp;:\mathsf{tr}(\ell_{12})(p_1)=p_2\\
H_r&amp;:\mathsf{tr}(r_{21})(p_2)=p_1.
\end{aligned}\]</span> which simplifies to <span class="math display">\[\begin{aligned}
p_1&amp;:v_1=v_1\\
p_2&amp;:v_1=v_2\\
H_\ell&amp;:g(f(\ell_{12}))^{-1}\cdot p_1\cdot \ell_{12}=p_2\\
H_r&amp;:=g(f(r_{21}))^{-1}\cdot p_2\cdot r_{21}= p_1
\end{aligned}\]</span> and then to <span class="math display">\[\begin{aligned}
p_1&amp;:v_1=v_1\\
p_2&amp;:v_1=v_2\\
H_\ell&amp;:(\ell_{12}\cdot r_{21})^{-1}\cdot p_1\cdot \ell_{12}=p_2\\
H_r&amp;:\ensuremath{\mathsf{refl}}_{v_1}\cdot p_2\cdot r_{21}= p_1
\end{aligned}\]</span></p>
<p>To solve all of these constraints we can choose <span class="math inline">\(p_1\stackrel{\mathrm{def}}{=}\ensuremath{\mathsf{refl}}_{v_1}\)</span>, which by consulting either <span class="math inline">\(H_\ell\)</span> or <span class="math inline">\(H_r\)</span> requires that we take <span class="math inline">\(p_2\stackrel{\mathrm{def}}{=}{r_{21}}^{-1}\)</span>.</p>
<p>Now examining <span class="math inline">\(f\circ g\)</span>, we have <span class="math display">\[\begin{aligned}
f(g(\ensuremath{\mathsf{base}}))&amp;=\ensuremath{\mathsf{base}}&amp;\\
f(g(\ensuremath{\mathsf{loop}}))&amp;=f(\ell_{12}\cdot r_{21})=\ensuremath{\mathsf{loop}}
\end{aligned}\]</span> and so we have an easy proof that this is the identity.</p>
<p>The proof of the more general case <span class="math inline">\([\![{C_n}]\!]_1 \simeq [\![{C_{n-1}}]\!]_1\)</span> is very similar. Take the maps <span class="math inline">\(f:[\![{C_n}]\!]_1\to [\![{C_{n-1}}]\!]_1\)</span>, <span class="math inline">\(g:[\![{C_{n-1}}]\!]_1\to [\![{C_n}]\!]_1\)</span> to be <span class="math display">\[\begin{aligned}
f(v_i)=v_i&amp;\quad(i=1,\ldots,n-1) &amp; g(v_i)&amp;=v_i&amp;\quad(i=1,\ldots,n-1)\\
f(v_n)=v_1&amp;\quad&amp; g(e_{i,i+1})&amp;=e_{i,i+1}&amp;\quad(i=1,\ldots,n-2)\\
f(e_{i,i+1})=e_{i,i+1}&amp;\quad(i=1,\ldots,n-1)&amp; g(e_{n-1,1})&amp;=e_{n-1,n}\cdot e_{n,1}&amp;\\
f(e_{n-1,n})=e_{n-1,1}&amp;&amp;&amp;&amp;\\
f(e_{n,1})=\ensuremath{\mathsf{refl}}_{v_1}&amp;&amp;&amp;&amp;
\end{aligned}\]</span> where <span class="math inline">\(f\)</span> should be thought of as shrinking <span class="math inline">\(e_{n,1}\)</span> so that <span class="math inline">\(v_n\)</span> coalesces into <span class="math inline">\(v_1\)</span>.</p>
<p>The proof that <span class="math inline">\(g\circ f\sim\ensuremath{\text{id}}_{[\![{C_n}]\!]_1}\)</span> proceeds as follows: the composition is definitionally the identity except <span class="math display">\[\begin{aligned}
g(f(v_n))&amp;=v_1\\
g(f(e_{n-1,n}))&amp;=e_{n-1,n}\cdot e_{n,1}\\
g(f(e_{n,1}))&amp;= \ensuremath{\mathsf{refl}}_{v_1}.
\end{aligned}\]</span> Guided by our previous experience we choose <span class="math inline">\({e_{n,1}}^{-1}:g(f(v_n))=v_n\)</span>, and define the pathovers by transport.</p>
<p>The proof that <span class="math inline">\(f\circ g\sim\ensuremath{\text{id}}_{[\![{C_{n-1}}]\!]_1}\)</span> requires only noting that <span class="math inline">\(f(g(e_{n-1,1}))=f(e_{n-1,n}\cdot e_{n,1})=e_{n-1,1}\cdot\ensuremath{\mathsf{refl}}_{v_1}=e_{n-1,1}\)</span>. ◻</p>
<div id="cor:gon" class="mycor">
<p><strong>Corollary 17</strong>. <em>All polygons are equivalent to <span class="math inline">\(S^1\)</span>, i.e. we have terms <span class="math inline">\(e_n:||[\![{C_n}]\!]_1=S^1||_{-1}\)</span>, and hence we have constructed a map from the unit type <span class="math inline">\(([\![{C_n}]\!]_1, e_n):\mathbb{1}\to \mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span>.</em></p>
</div>
<p><em>Proof.</em> We can add <span class="math inline">\(n-1\)</span> points to <span class="math inline">\(S^1\)</span> and use Lemma <a href="#lem:addpoints" data-reference-type="ref" data-reference="lem:addpoints">16</a>. ◻</p>
<p>If we cyclically permute the vertices of a simplicial polygon, what map is induced on the realization and the bare types within?</p>
<p>Let <span class="math inline">\(R:[{v_1\cdots v_n}]\to [{v_1\cdots v_n}]\)</span> (for “rotation”) be the map sending <span class="math inline">\(v_i\mapsto v_{i+1}\)</span> and <span class="math inline">\(v_n\mapsto v_0\)</span>. This map clearly preserves the edges, and so is a map of simplicial complexes, and extends to a map <span class="math inline">\([\![{R}]\!]:[\![{v_1\cdots v_n}]\!]\to [\![{v_1\cdots v_n}]\!]\)</span>. A key point is that maps that have access to the combinatorial data are more numerous than the maps on the resulting bare types:</p>
<div class="mylemma">
<p><strong>Lemma 18</strong>. <em>The map <span class="math inline">\([\![{R}]\!]_1: [\![{v_1\cdots v_n}]\!]_1\to [\![{v_1\cdots v_n}]\!]_1\)</span> is .</em></p>
</div>
<h2 data-number="3.4" id="the-octahedron-model-of-the-sphere"><span class="header-section-number">3.4</span> The octahedron model of the sphere</h2>
<p>We will create our first combinatorial surface, an octahedron. We will not prove that this type is equivalent to the sphere. In <span class="math inline">\(\mathsf{SimpCompSet_n}\)</span> the combinatorial data of the faces can be represented with a <em>Hasse diagram</em>, which shows the poset of inclusions in a graded manner, with a special top and bottom element. We give an octahedron in Figure <a href="#fig:hasse_octohedron" data-reference-type="ref" data-reference="fig:hasse_octohedron">5</a>. The names of the vertices are short for white, yellow, blue, red, green, and orange, the colors of the faces of a Rubik’s cube. The octahedron is the dual of the cube, with each vertex corresponding to a face.</p>
<figure id="fig:hasse_octohedron">
<img src="./41cfa9cf6e056c83cc79c2711f6ee0981317076b.svg" />
<figcaption>Hasse diagram of an octahedron <span class="math inline">\(O\)</span>. The row of singletons is <span class="math inline">\(O_0\)</span> and above it are <span class="math inline">\(O_1\)</span> and <span class="math inline">\(O_2\)</span>.</figcaption>
</figure>
<p>Applying the map <span class="math inline">\(\mathcal{R}\)</span> to <span class="math inline">\(O_0\to O_1\to O\)</span> gives the presented type <span class="math inline">\(\ensuremath{\mathbb{O}}_0\to \ensuremath{\mathbb{O}}_1\to \ensuremath{\mathbb{O}}\)</span>.</p>
<figure>
<img src="./ff7f3a1e9ad288427a1f8fe354f5e5e4112b62fd.svg" />
<figcaption>The marked presented type <span class="math inline">\(\ensuremath{\mathbb{O}}\)</span> which has 6 points, 12 1-paths, 8 2-paths.</figcaption>
</figure>
<h1 data-number="4" id="bundles-connections-and-curvature"><span class="header-section-number">4</span> Bundles, connections, and curvature</h1>
<p>A map out of a higher combinatorial manifold has various components. These line up with classical definitions, and identifying those is a primary purpose of this note.</p>
<h2 data-number="4.1" id="definitions"><span class="header-section-number">4.1</span> Definitions</h2>
<div id="def:connection" class="mydef">
<p><strong>Definition 19</strong>. <em>If <span class="math inline">\([\![{M}]\!]\)</span> is a higher combinatorial <span class="math inline">\(n\)</span>-manifold and <span class="math inline">\(f_k:\ensuremath{\mathbb{M}}_k\to\mathcal{U}\)</span> are type families on each skeleton such that all the triangles commute in the diagram:</em></p>
</div>
<p><img src="./b0134737d5afd51d9a45a17076e859402ad4fc49.svg" alt="image" /></p>
<p>and such that for each pushout defining <span class="math inline">\(\ensuremath{\mathbb{M}}_k\)</span> we have the diagram</p>
<p><img src="./27ce799d943abb49f8e69dd66e145faf86086a4e.svg" alt="image" /></p>
<p>the outer square of which restricts on each face to the diagram</p>
<p><img src="./7caceb27260cf96ff3d9656d41a3c14f503e0c87.svg" alt="image" /></p>
<p>then we say</p>
<ul>
<li><p>The map <span class="math inline">\(f_k\)</span> is a <strong><span class="math inline">\(k\)</span>-bundle</strong> on <span class="math inline">\(\ensuremath{\mathbb{M}}_k\)</span>.</p></li>
<li><p>The pair given by the map <span class="math inline">\(f_k\)</span> and the proof <span class="math inline">\(f_k\circ \imath_{k-1}=f_{k-1}\)</span> that <span class="math inline">\(f_k\)</span> extends <span class="math inline">\(f_{k-1}\)</span> is called a <strong><span class="math inline">\(k\)</span>-connection on the bundle <span class="math inline">\(f_{k-1}\)</span></strong>.</p></li>
<li><p>The filler <span class="math inline">\(\flat_k\)</span> is called a <strong>flatness structure for the face <span class="math inline">\(m_k\)</span></strong>.</p></li>
</ul>
<p>The definitions can be digested to give</p>
<div class="mylemma">
<p><strong>Lemma 20</strong>. <em>Given <span class="math inline">\(f_{k-1}\)</span> as above, a <span class="math inline">\(k\)</span>-connection exists if and only if there exists a flatness structure for each <span class="math inline">\(k\)</span>-face.</em></p>
</div>
<div class="mynote">
<p><strong>Remark 21</strong>. <em>Another classical object we can identify here is a <em>gauge transformation</em>, which is a bundle automorphism <span class="math inline">\(H:f\sim f\stackrel{\mathrm{def}}{=}\prod_{m:\ensuremath{\mathbb{M}}}f(m)=f(m)\)</span>. If we have <span class="math inline">\(||H=\ensuremath{\text{id}}_f||_{-1}\)</span> then the gauge transformation is called <em>small</em>, else <em>large</em>.</em></p>
</div>
<h2 data-number="4.2" id="connections-as-local-trivializations"><span class="header-section-number">4.2</span> Connections as local trivializations</h2>
<p>This section can ve viewed as an extended remark. The observation we want to make is that the data of a <span class="math inline">\(k\)</span>-bundle is related to the construction of a trivialization: the fiber at one vertex can be extended throughout the face coherently, using the connection (the extension of the classifying map to the edges) to specify isomorphisms with the fibers at the other points, and the higher connections to establish commutativity between these.</p>
<p>An important context for these remarks is if we imagine that the simplicial complex we started with is in fact a <em>Cech complex</em> of a good open cover <span class="math inline">\(\{U_i\}\)</span> (a cover by contractible open sets, each finite intersection of which is also contractible). This is just to say the vertices <span class="math inline">\(v_i\)</span> would represent the combinatorial data of the set of charts <span class="math inline">\(\{U_i\}\)</span> themselves, and the edges are formed if two charts overlap. The <span class="math inline">\(k\)</span>-faces are the <span class="math inline">\(k\)</span>-way overlaps, if any. For a good introduction to this point of view, see the introduction in Bott and Tu <span class="citation" data-cites="bott_tu"> (<a href="#ref-bott_tu" role="doc-biblioref">Bott &amp; Tu, 1982</a>)</span>. It bears emphasizing: the resulting <em>higher</em> types are the same ones we’ve been working with, it’s only the origin of the combinatorial data that we’re reimagining.</p>
<p>Continuing the story, the type family <span class="math inline">\(f\)</span> at one vertex <span class="math inline">\(v_i\)</span>, <span class="math inline">\(f(v_i)\)</span> would represent a trivial bundle <span class="math inline">\(U_i\times f(v_i)\)</span> on one chart. Consider a 2-face <span class="math inline">\(F=\{v_1, v_2, v_3\}\)</span> and types <span class="math inline">\(f(v_1), f(v_2), f(v_3)\)</span> at the vertices. Extending <span class="math inline">\(f\)</span> to the edges <span class="math inline">\(\{e_{12}, e_{23}, e_{31}\}\)</span> provides isomorphisms <span class="math inline">\(f(e_{12}):f(v_1)=f(v_2)\)</span> and so on. There is a condition to check, however. We need the compatibility <span class="math inline">\(f(e_{31})\circ f(e_{23})\circ f(e_{12})=\ensuremath{\text{id}}_{f(v_1)}\)</span> on the 3-way overlap of the charts. This is provided by the flatness structure <span class="math inline">\(\flat(F)\)</span>, which is exactly a proof that the holonomy around the triangle is equal to the identity.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>The classical theory of bundles on smooth manifolds is often presented in terms of just such combinatorial data, constructed from an appropriate atlas of charts and their overlaps. This is very much dual to the viewpoint where points are points, edges are paths, and so on. If one started with a cube, and covered it with six charts that each contained a different face (plus a little overlap), and formed the Cech complex of this data, you would arrive exactly at the dual polyhedron to the cube: the octahedron.</p>
<h2 data-number="4.3" id="the-tangent-bundle-of-the-sphere"><span class="header-section-number">4.3</span> The tangent bundle of the sphere</h2>
<p>We will build up a map <span class="math inline">\(T\)</span> out of <span class="math inline">\(\ensuremath{\mathbb{O}}\)</span> which is meant to be like the circle bundle of a tangent bundle. And so we will begin with the intrinsic data of the link at each point: taking the link of a vertex gives us a map from vertices to polygons.</p>
<div class="mydef">
<p><strong>Definition 22</strong>. <em><span class="math inline">\(T_0\stackrel{\mathrm{def}}{=}\mathop{\mathrm{\mathsf{link}}}:\ensuremath{\mathbb{O}}_0\to\mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span> is given by: <span class="math display">\[\begin{aligned}
\mathop{\mathrm{\mathsf{link}}}(w) &amp;= brgo &amp; \mathop{\mathrm{\mathsf{link}}}(r) &amp;= wbyg \\
\mathop{\mathrm{\mathsf{link}}}(y) &amp;= bogr &amp; \mathop{\mathrm{\mathsf{link}}}(g) &amp;= wryo \\
\mathop{\mathrm{\mathsf{link}}}(b) &amp;= woyr &amp; \mathop{\mathrm{\mathsf{link}}}(o) &amp;= wgyb
\end{aligned}\]</span> We chose these orderings for the vertices in the link, by visualizing standing at the given vertex as if it were the north pole, then looking south and enumerating the link in clockwise order, starting from <span class="math inline">\(w\)</span> if possible, else <span class="math inline">\(b\)</span>.</em></p>
</div>
<figure id="fig:triangle_of_equators">
<img src="./5223124258db050f495250e281a65d462714f6df.svg" />
<img src="./f8ad0fbb66a7ad51b3cb4db7a0f35ea8a8a56a4b.svg" />
<img src="./d3b55304a407c9ca808e19bf9256206529608d82.svg" />
<figcaption><span class="math inline">\(\mathop{\mathrm{\mathsf{link}}}\)</span> for the vertices <span class="math inline">\(w, b\)</span> and <span class="math inline">\(r\)</span>.</figcaption>
</figure>
<p>To extend <span class="math inline">\(T_0\)</span> to a function <span class="math inline">\(T_1\)</span> on the 1-skeleton we have complete freedom. Defining a map by induction makes clear that the action on paths is its own structure. Two functions on the octahedron could agree on points but differ on edges. We are going to identify this 1-dimensional freedom with a connection:</p>
<p>Continuing the example, we will do something “tangent bundley”, imagining how <span class="math inline">\(T_1\)</span> changes as we slide from point to point in the embedding shown in the figures. Sliding from <span class="math inline">\(w\)</span> to <span class="math inline">\(b\)</span> and tipping the link as we go, we see <span class="math inline">\(r\mapsto r\)</span> and <span class="math inline">\(o\mapsto o\)</span> because those lie on the axis of rotation. Then <span class="math inline">\(g\mapsto w\)</span> and <span class="math inline">\(b\mapsto y\)</span>.</p>
<div class="mydef">
<p><strong>Definition 23</strong>. <em>Define <span class="math inline">\(T_1:\ensuremath{\mathbb{O}}_1\to\mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span> on just the 1-skeleton by extending <span class="math inline">\(T_0\)</span> as follows: Transport away from <span class="math inline">\(w\)</span>:</em></p>
<ul>
<li><p><em><span class="math inline">\(T_1(wb):[b, r, g, o]\mapsto [y, r, w, o]\)</span> (<span class="math inline">\(r, o\)</span> fixed)</em></p></li>
<li><p><em><span class="math inline">\(T_1(wr):[b, r, g, o]\mapsto [b, y, g, w]\)</span> (<span class="math inline">\(b, g\)</span> fixed)</em></p></li>
<li><p><em><span class="math inline">\(T_1(wg):[b, r, g, o]\mapsto [w, r, y, o]\)</span></em></p></li>
<li><p><em><span class="math inline">\(T_1(wo):[b, r, g, o]\mapsto [b, w, g, y]\)</span></em></p></li>
</ul>
<p><em>Transport away from <span class="math inline">\(y\)</span>:</em></p>
<ul>
<li><p><em><span class="math inline">\(T_1(yb):[b, o, g, r]\mapsto [w, o, y, r]\)</span></em></p></li>
<li><p><em><span class="math inline">\(T_1(yr):[b, o, g, r]\mapsto [b, y, g, w]\)</span></em></p></li>
<li><p><em><span class="math inline">\(T_1(yg):[b, o, g, r]\mapsto [y, o, w, r]\)</span></em></p></li>
<li><p><em><span class="math inline">\(T_1(yo):[b, o, g, r]\mapsto [b, w, g, y]\)</span></em></p></li>
</ul>
<p><em>Transport along the equator:</em></p>
<ul>
<li><p><em><span class="math inline">\(T_1(br):[w, o, y, r]\mapsto [w, b, y, g]\)</span></em></p></li>
<li><p><em><span class="math inline">\(T_1(rg):[w, b, y, g]\mapsto [w, r, y, o]\)</span></em></p></li>
<li><p><em><span class="math inline">\(T_1(go):[w, r, y, o]\mapsto [w, g, y, b]\)</span></em></p></li>
<li><p><em><span class="math inline">\(T_1(ob):[w, g, y, b]\mapsto [w, o, y, r]\)</span></em></p></li>
</ul>
</div>
<p>It’s very important to be able to visualize what <span class="math inline">\(T_1\)</span> does to triangular paths such as <span class="math inline">\(wb\cdot br\cdot rw\)</span> (which circulates around the boundary of face <span class="math inline">\(wbr\)</span>). You can see it if you imagine Figure <a href="#fig:triangle_of_equators" data-reference-type="ref" data-reference="fig:triangle_of_equators">6</a> as the frames of a short movie. Or you can place your palm over the top of a cube and note where your fingers are pointing, then slide your hand to an equatorial face, then along the equator, then back to the top. The answer is: you come back rotated clockwise by a quarter-turn.</p>
<div id="def:octahedron_holonomy" class="mydef">
<p><strong>Definition 24</strong>. <em>The map <span class="math inline">\(R:C_4\to C_4\)</span> rotates by one quarter turn, one “click":</em></p>
<div class="multicols">
<p><em><span>2</span></em></p>
<ul>
<li><p><em><span class="math inline">\(R(c_1) = c_2\)</span></em></p></li>
<li><p><em><span class="math inline">\(R(c_2) = c_3\)</span></em></p></li>
<li><p><em><span class="math inline">\(R(c_3) = c_4\)</span></em></p></li>
<li><p><em><span class="math inline">\(R(c_4) = c_1\)</span></em></p></li>
<li><p><em><span class="math inline">\(R(c_1c_2) = c_2c_3\)</span></em></p></li>
<li><p><em><span class="math inline">\(R(c_2c_3) = c_3c_4\)</span></em></p></li>
<li><p><em><span class="math inline">\(R(c_3c_4) = c_4c_1\)</span></em></p></li>
<li><p><em><span class="math inline">\(R(c_4c_1) = c_1c_2\)</span></em></p></li>
</ul>
</div>
</div>
<p>Note by univalence the equivalence <span class="math inline">\(R\)</span> gives a loop in the universe, a term of <span class="math inline">\(C_4=_{\mathrm{EM}(\ensuremath{\mathbb{Z}},1)}C_4\)</span>.</p>
<p>Now let’s extend <span class="math inline">\(T_1\)</span> to all of <span class="math inline">\(\ensuremath{\mathbb{O}}\)</span> by providing values for the eight faces. The face <span class="math inline">\(wbr\)</span> is a path from <span class="math inline">\(\ensuremath{\mathsf{refl}}_w\)</span> to the concatenation <span class="math inline">\(wb\cdot br\cdot rw\)</span>, and so the image of <span class="math inline">\(wbr\)</span> under the extended version of <span class="math inline">\(T_1\)</span> must be a homotopy from <span class="math inline">\(\ensuremath{\mathsf{refl}}_{T_1(w)}\)</span> to <span class="math inline">\(T_1(wb\cdot br\cdot rw)\)</span>. Here <em>there is no additional freedom</em>.</p>
<div id="def:octahedron_curvature" class="mydef">
<p><strong>Definition 25</strong>. <em>Define <span class="math inline">\(T_2:\ensuremath{\mathbb{O}}\to\mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span> by extending <span class="math inline">\(T_1\)</span> to the faces as follows:</em></p>
<div class="multicols">
<p><em><span>2</span></em></p>
<ul>
<li><p><em><span class="math inline">\(T_2(wbr)=H_R\)</span></em></p></li>
<li><p><em><span class="math inline">\(T_2(wrg)=H_R\)</span></em></p></li>
<li><p><em><span class="math inline">\(T_2(wgo)=H_R\)</span></em></p></li>
<li><p><em><span class="math inline">\(T_2(ybo)=H_R\)</span></em></p></li>
<li><p><em><span class="math inline">\(T_2(yrb)=H_R\)</span></em></p></li>
<li><p><em><span class="math inline">\(T_2(ygr)=H_R\)</span></em></p></li>
<li><p><em><span class="math inline">\(T_2(yog)=H_R\)</span></em></p></li>
<li><p><em><span class="math inline">\(T_2(ybo)=H_R\)</span></em></p></li>
</ul>
</div>
<p><em>where <span class="math inline">\(H_R:R=\ensuremath{\mathsf{refl}}_{C_4}\)</span> is the obvious homotopy given by composition with <span class="math inline">\(R^{-1}\)</span>. Passing through univalence we get a 2-path between <span class="math inline">\(R\)</span> and <span class="math inline">\(\ensuremath{\mathsf{refl}}\)</span> in the loop space <span class="math inline">\(C_4=_{\mathrm{EM}(\ensuremath{\mathbb{Z}},1)}C_4\)</span>.</em></p>
</div>
<h2 data-number="4.4" id="existence-of-connections"><span class="header-section-number">4.4</span> Existence of connections</h2>
<p>How confident can we be that we can always define a connection on an arbitrary combinatorial manifold? Two things make the octahedron example special: the link is a 4-gon at every vertex, and every edge extends to a symmetry of the entire octahedron, embedded in 3-dimensional space. This imposed a coherence on the interactions of all the choices we made for the connection, which we can worry may not exist for more complex combinatorial data.</p>
<p>We know as a fact outside of HoTT that any combinatorial surface that has been realized as a triangulated surface embedded in 3-dimensional euclidean space can inherit the parallel transport entailed in the embedding. We could then approximate that data to arbitrary precision with enough subdivision of the fibers of <span class="math inline">\(T\)</span>.</p>
<p>What would a proof inside of HoTT look like? We will leave this as an open question.</p>
<h1 data-number="5" id="vector-fields"><span class="header-section-number">5</span> Vector fields</h1>
<h2 data-number="5.1" id="definition"><span class="header-section-number">5.1</span> Definition</h2>
<p>Vector fields are sections of the tangent bundle of a manifold. We do not have a general theory of tangent bundles, even for 2-dimensional higher combinatorial manifolds, since we cannot yet prove that connections always exist on the 1-skeleton. But <em>given</em> an extension <span class="math inline">\(T\)</span> of the <span class="math inline">\(\mathop{\mathrm{\mathsf{link}}}\)</span> function, we can consider the type of sections <span class="math inline">\(\prod_{x:\ensuremath{\mathbb{M}}_1}T_1(x)\)</span>.</p>
<div class="mydef">
<p><strong>Definition 26</strong>. <em>A <strong>vector field</strong> on a higher combinatorial 2-manifold <span class="math inline">\(\ensuremath{\mathbb{M}}\)</span> equipped with type family <span class="math inline">\(T:\ensuremath{\mathbb{M}}\to\mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span> that extends <span class="math inline">\(\mathop{\mathrm{\mathsf{link}}}\)</span> is a term <span class="math inline">\(X:\prod_{x:\ensuremath{\mathbb{M}}_1}T_1(x)\)</span>. It may be possible to extend <span class="math inline">\(X\)</span> to one or more faces of <span class="math inline">\(\ensuremath{\mathbb{M}}\)</span>, but we call faces for which <span class="math inline">\(X\)</span> cannot be extended are called <strong>zeros of the vector field</strong>.</em></p>
</div>
<div class="mynote">
<p><strong>Remark 27</strong>. <em>A section <span class="math inline">\(\prod_{x:\ensuremath{\mathbb{M}}}f(x)\)</span> for <span class="math inline">\(f:\ensuremath{\mathbb{M}}\to\mathrm{K}(\ensuremath{\mathbb{Z}},2)\)</span> is a trivialization of the bundle. The fact that an orientation suffices to factor the tangent bundle of a 2-manifold (which <em>a priori</em> maps to <span class="math inline">\(\mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span>) through a principal bundle classifier is special to dimension 2. For higher dimensional manifolds the tangent bundle is a bundle of spheres, and even if the bundle is oriented it is not necessarily a principal bundle. On the other hand, the <span class="math inline">\(n\)</span>-truncation modal operator maps the type of <span class="math inline">\(n\)</span>-spheres to the classifying space <span class="math inline">\(\mathrm{K}(\ensuremath{\mathbb{Z}},n)\)</span>, and so another way to phrase this remark is that <span class="math inline">\(S^1\)</span> is the only <span class="math inline">\(n\)</span>-sphere which is <span class="math inline">\(n\)</span>-truncated.</em></p>
</div>
<p>On the 0-skeleton <span class="math inline">\(X\)</span> picks a point in each link, i.e. a neighbor of each vertex. On a path <span class="math inline">\(p:x=_\ensuremath{\mathbb{M}}y\)</span>, <span class="math inline">\(X\)</span> assigns a dependent path over <span class="math inline">\(p\)</span>, which as we know is a term <span class="math inline">\(\pi:\mathsf{tr}(p)(X(x))=_{T_1 y} X(y)\)</span>.</p>
<div class="mynote">
<p><strong>Remark 28</strong>. <em>Concrete pathover terms such as <span class="math inline">\(\pi\)</span> couple together the connection (the transport) and <span class="math inline">\(X\)</span>. The transport is needed to provide a single type in which to compare the two values of <span class="math inline">\(X\)</span>. The path <span class="math inline">\(\pi\)</span> therefore reflects both the movement of <span class="math inline">\(X\)</span> along the path <span class="math inline">\(p\)</span>, and the moving lens that allows us to examine in a single fiber the two points <span class="math inline">\(X(x)\)</span> and <span class="math inline">\(X(y)\)</span> as well as <span class="math inline">\(X(p)\)</span>.</em></p>
</div>
<h2 data-number="5.2" id="swirling"><span class="header-section-number">5.2</span> Swirling</h2>
<p>Classically, vector fields are seen to swirl around between points. We can see this in HoTT as well, though in contrast to the classical explanations we always have a connection that interacts with the vector field.</p>
<p>Consider a vertex <span class="math inline">\(x:\ensuremath{\mathbb{M}}\)</span>, a face <span class="math inline">\(F\)</span> containing vertices <span class="math inline">\(x, y, z\)</span>, and the boundary path <span class="math inline">\(\ell\stackrel{\mathrm{def}}{=}e_{xy}\cdot e_{yz} \cdot e_{zx}\)</span>. We can calculate <span class="math inline">\(X(\ell)\)</span> by concatenating the data along the path. As we visit each point we accumulate more information:</p>
<ol>
<li><p>In <span class="math inline">\(T_1(x)\)</span> we have</p>
<ol>
<li><p>the point <span class="math inline">\(X(x)\)</span>.</p></li>
</ol></li>
<li><p>In <span class="math inline">\(T_1(y)\)</span> we have</p>
<ol>
<li><p>point <span class="math inline">\(X(y)\)</span></p></li>
<li><p>point <span class="math inline">\(\mathsf{tr}(e_{xy})(X(x))\)</span></p></li>
<li><p>the path <span class="math inline">\(X(e_{xy}):\mathsf{tr}(e_{xy})(X(x))=X(y)\)</span> from (b) to (a).</p></li>
</ol></li>
<li><p>In <span class="math inline">\(T_1(z)\)</span> we have</p>
<ol>
<li><p>point <span class="math inline">\(X(z)\)</span></p></li>
<li><p>point <span class="math inline">\(\mathsf{tr}(e_{yz})(X(y))\)</span></p></li>
<li><p>point <span class="math inline">\(\mathsf{tr}(e_{yz})\circ\mathsf{tr}(e_{xy})(X(x))\)</span></p></li>
<li><p>path <span class="math inline">\(X(e_{yz}):\mathsf{tr}(e_{yz})(X(y))=X(z)\)</span> from (b) to (a)</p></li>
<li><p>path <span class="math inline">\(\mathsf{tr}(e_{yz})(X(e_{xy}))\)</span> from (c) to (b)</p></li>
</ol></li>
<li><p>Then back at <span class="math inline">\(T_1(x)\)</span> we have</p>
<ol>
<li><p>point <span class="math inline">\(X(x)\)</span></p></li>
<li><p>point <span class="math inline">\(\mathsf{tr}(e_{zx})(X(z))\)</span></p></li>
<li><p>point <span class="math inline">\(\mathsf{tr}(e_{zx})\circ\mathsf{tr}(e_{yz})(X(y))\)</span></p></li>
<li><p>point <span class="math inline">\(\mathsf{tr}(e_{zx})\circ\mathsf{tr}(e_{yz})\circ\mathsf{tr}(e_{xy})(X(x))\)</span>, i.e. <span class="math inline">\(\mathsf{tr}(\ell)(X(x))\)</span></p></li>
<li><p>path <span class="math inline">\(X(e_{zx}): \mathsf{tr}(e_{zx})(X(z))=X(x)\)</span> from (b) to (a)</p></li>
<li><p>path <span class="math inline">\(\mathsf{tr}(e_{zx})(X(e_{yz}))\)</span> from (c) to (b)</p></li>
<li><p>path <span class="math inline">\(\mathsf{tr}(e_{zx})\circ\mathsf{tr}(e_{yz})(X(e_{xy}))\)</span> from (d) to (c).</p></li>
</ol></li>
</ol>
<p>As we traverse an edge, say <span class="math inline">\(e_{xy}\)</span>, we get a path in <span class="math inline">\(T_1(y)\)</span> which is the image of <span class="math inline">\(e_{xy}\)</span> under <span class="math inline">\(X\)</span>. Although this path is then transported along further edges of the triangle, it will help us to think of it as maintaining its relationship to <span class="math inline">\(e_{xy}\)</span>:</p>
<div class="mydef">
<p><strong>Definition 29</strong>. <em>If <span class="math inline">\(e_{xy}:x=_{\ensuremath{\mathbb{M}}_1} y, e_{yz}:y=_{\ensuremath{\mathbb{M}}_1}z\)</span> are paths in <span class="math inline">\(\ensuremath{\mathbb{M}}_1\)</span> and <span class="math inline">\(X\)</span> is a nonvanishing vector field on <span class="math inline">\(\ensuremath{\mathbb{M}}_1\)</span>, then we call <span class="math inline">\(\mathsf{tr}(e_{yz})(X(e_{xy}))\)</span> <strong>the contribution on <span class="math inline">\(e_{xy}\)</span> of <span class="math inline">\(X\)</span></strong>, even though this is a path in <span class="math inline">\(T_1(z)\)</span>.</em></p>
</div>
<p>As we traverse an additional edge this image is simply mapped to the next vertex through the lens of transport, which acts similarly on all the points in a fiber. The image is carried first to <span class="math inline">\(\mathsf{tr}(e_{yz})(X(e_{xy}))\)</span> then to <span class="math inline">\(\mathsf{tr}(e_{zx})\circ\mathsf{tr}(e_{yz})(X(x))\)</span>.</p>
<p>At stage 4 we have three paths, each consisting of <span class="math inline">\(X\)</span> acting on a single edge of the triangle, mapped with some transport to <span class="math inline">\(T_1(x)\)</span>. We see that these three can be concatenated to form a path <span class="math inline">\(X(\ell):\mathsf{tr}(\ell)(X(x))=X(x)\)</span>.</p>
<div class="mynote">
<p><strong>Remark 30</strong>. <em>In Hopf <span class="citation" data-cites="hopf"> (<a href="#ref-hopf" role="doc-biblioref">Hopf, 1983</a>)</span> and in Needham <span class="citation" data-cites="needham"> (<a href="#ref-needham" role="doc-biblioref">Needham, 2021</a>)</span>, the value <span class="math inline">\(X(e_{xy})\)</span> is called “the change in angle between <span class="math inline">\(X\)</span> and <span class="math inline">\(X(x)_{||}\)</span> along the edge <span class="math inline">\(e_{xy}\)</span>,” where by <span class="math inline">\(X(x)_{||}\)</span> we mean the transport of the fixed single vector <span class="math inline">\(X(x)\)</span> to the point <span class="math inline">\(X(y)\)</span>, i.e. <span class="math inline">\(\mathsf{tr}(e_{xy})(X(x))\)</span>. The concatenation <span class="math inline">\(X(\ell)\)</span> is called “the sum of the changes in angle along each edge.” This remark is meant to help anyone intending to make further comparisons with classical results.</em></p>
</div>
<p>When <span class="math inline">\(T_1\)</span> has an extension to <span class="math inline">\(F\)</span> we can obtain a second path in <span class="math inline">\(\mathsf{tr}(\ell)(X(x))=X(x)\)</span>! Namely given a filler path <span class="math inline">\(\ell=_{v=_\ensuremath{\mathbb{M}}v} \ensuremath{\mathsf{refl}}(v)\)</span> that fills the loop, an extension of <span class="math inline">\(T_1\)</span> to <span class="math inline">\(F\)</span> provides by functoriality a corresponding path <span class="math inline">\(T_1(\ell)=_{T_1(v)=T_1(v)}\ensuremath{\text{id}}(T_1(v))\)</span>, which is a homotopy between these two automorphisms of <span class="math inline">\(T_1(v)\)</span> that we called the flatness structure on <span class="math inline">\(F\)</span>. Evaluating this homotopy at <span class="math inline">\(X(x)\)</span> provides the term <span class="math inline">\(\flat(\ell)(X(x)):X(x)=\mathsf{tr}(\ell)(X(x))\)</span> (and its inverse is hence the promised second path).</p>
<p>Concatenating <span class="math inline">\(\flat(\ell)(X(x))\cdot X(\ell)(X(x))\)</span> gives a loop in the pointed type <span class="math inline">\((T_1(x), X(x))\)</span>. This is a term in <span class="math inline">\(\ensuremath{\mathbb{Z}}\)</span>:</p>
<div id="def:index" class="mydef">
<p><strong>Definition 31</strong>. <em>The <strong>index</strong> of <span class="math inline">\(X\)</span> at <span class="math inline">\(x\)</span> on the face <span class="math inline">\(F\)</span> is <span class="math inline">\(\flat(\ell)(X(x))\cdot X(\ell)(X(x)):\ensuremath{\mathbb{Z}}\)</span>.</em></p>
</div>
<div class="mynote">
<p><strong>Remark 32</strong>. <em>Intuitively, <span class="math inline">\(X(\ell)\)</span> combines the swirling of <span class="math inline">\(X\)</span> with the twisting of the connection, and prepending with the flatness structure erases the effect of the connection, leaving just the swirling of <span class="math inline">\(X\)</span>. This should line up with the classical definition of index, which is also an integer.</em></p>
</div>
<h1 data-number="6" id="total-constructions"><span class="header-section-number">6</span> Total constructions</h1>
<p>We wish to make computations that combine contributions from every face of a combinatorial 2-manifold. To do this we will add some structure and then prove that the definitions are independent of that structure.</p>
<div class="mydef">
<p><strong>Definition 33</strong>. <em>A <strong>total enumeration of faces</strong> for a combinatorial 2-manifold <span class="math inline">\(\ensuremath{\mathbb{M}}\)</span> with underlying simplicial complex <span class="math inline">\(M=[M_0, M_1, M_2]\)</span> consists of</em></p>
<ol>
<li><p><em>A “master basepoint” <span class="math inline">\(m:M_0\)</span>.</em></p></li>
<li><p><em>For each face <span class="math inline">\(F:M_2\)</span> with vertices <span class="math inline">\(\{v_1, v_2, v_3\}\)</span> an enumeration of its vertices <span class="math inline">\([v_1, v_2, v_3]\)</span>, including the choice of the first vertex in the enumeration as the basepoint of <span class="math inline">\(F\)</span>, which is <strong>globally compatible</strong> with the choices for the other faces, meaning that when two faces <span class="math inline">\(F_1,F_2\)</span> share an edge <span class="math inline">\(\{v, w\}\)</span>, then one of the faces includes the sublist <span class="math inline">\([v, w]\)</span> and the other includes <span class="math inline">\([w, v]\)</span>.</em></p></li>
<li><p><em>An ordering of the faces <span class="math inline">\([F_1,\ldots,F_n]\)</span>.</em></p></li>
<li><p><em>For each face <span class="math inline">\(F\)</span> a path <span class="math inline">\(p_F:m=_\ensuremath{\mathbb{M}}F_v\)</span> and a loop <span class="math inline">\(\ell_F\stackrel{\mathrm{def}}{=}p_F\cdot e_{12}\cdot e_{23}\cdot e_{31}\cdot p_F^{-1}\)</span> where <span class="math inline">\(e_{ij}:v_i=v_j\)</span> are the paths corresponding to the edges.</em></p></li>
</ol>
<p><em>Two enumerations that differ only in the ordering of vertices (2.) are said to have the <strong>same orientation</strong> if it is true for every face that the two orderings of vertices differ by an even orientation.</em></p>
</div>
<p>Note that the last bullet of the definition is the only one that uses the realization <span class="math inline">\(\ensuremath{\mathbb{M}}\)</span>.</p>
<div class="mynote">
<p><strong>Remark 34</strong>. <em>For such an enumeration to exist the underlying simplicial complex must be <em>orientable</em> in a classical sense. We are not going to explore this requirement internally in HoTT, nor prove any relationship between orientability of the set-based complex and orientation in the sense of factoring classifying maps through <span class="math inline">\(\mathrm{K}(\ensuremath{\mathbb{Z}},2)\to\mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span>.</em></p>
</div>
<div class="myex">
<p><strong>Example 35</strong>. <em>The octahedron: for <span class="math inline">\(\ensuremath{\mathbb{O}}\)</span> we might choose <span class="math inline">\(b\)</span> as the master basepoint, as well as the basepoint for four of the faces. For the other four faces we could choose <span class="math inline">\(g\)</span> as the basepoint. We could choose <span class="math inline">\(br\cdot rg\)</span> as the path between the basepoints, and we could order the faces like this: <span class="math inline">\([bwo, brw, boy, byr, gow, gwr, gry, gyo]\)</span>.</em></p>
</div>
<div class="mydef">
<p><strong>Definition 36</strong>. <em>Given a total enumeration of faces, the concatenation <span class="math inline">\(\ell_{\mathrm{tot}}\stackrel{\mathrm{def}}{=}\ell_{F_1}\cdot\cdots\cdot\ell_{F_n}\)</span> is called <strong>the total loop</strong> of the enumeration.</em></p>
</div>
<figure id="fig:lasso">
<img src="./aa281afe7867f5b1bc6e068f4632201285d10a78.svg" />
<figcaption>A loop <span class="math inline">\(\ell_F:m=_\ensuremath{\mathbb{M}}m\)</span> around the face <span class="math inline">\(F\)</span>.</figcaption>
</figure>
<h2 data-number="6.1" id="total-holonomy"><span class="header-section-number">6.1</span> Total holonomy</h2>
<p>Given a total enumeration of faces we can form the compositions <span class="math inline">\(T\circ\ell_{F_i}\)</span> with the associated loop to obtain holonomy isomorphisms <span class="math inline">\(T\circ\ell_{F_i}:Tm=Tm\)</span>. We can concatenate all the loops <span class="math inline">\(\ell_{F_1}\cdot\cdots\cdot\ell_{F_n}\)</span> and obtain a <em>total holonomy</em> <span class="math inline">\(T\circ(\ell_{F_1}\cdot\cdots\cdot\ell_{F_n}):Tm=Tm\)</span>.</p>
<div class="mydef">
<p><strong>Definition 37</strong>. <em>The <strong>total holonomy</strong> of a total enumeration of faces is the map <span class="math inline">\(T\circ(\ell_{F_1}\cdot\cdots\cdot\ell_{F_n}):Tm=Tm\)</span>.</em></p>
</div>
<div class="myprop">
<p><strong>Proposition 38</strong>. <em>The holonomy <span class="math inline">\(\ell_F\)</span> around a face <span class="math inline">\(F\)</span> is conjugated if we change the path <span class="math inline">\(p_F\)</span> or the basepoint <span class="math inline">\(m\)</span>. The holonomy becomes the inverse automorphism if we change the enumeration of <span class="math inline">\(F\)</span> by an odd permutation of its vertices (but keep the basepoint fixed).</em></p>
</div>
<p><em>Proof.</em> If we change the path <span class="math inline">\(p_F\)</span> to a homotopic path <span class="math inline">\(p&#39;_F\)</span>, then the change is made up of a finite sequence of moves like the one in Figure <a href="#fig:tail_move" data-reference-type="ref" data-reference="fig:tail_move">8</a>, where the triangle <span class="math inline">\(xyz\)</span> bounds a face. Then <span class="math inline">\(p_{F}\)</span> is given by <span class="math display">\[(p\cdot e_{xy})\cdot (q\cdot e_{12}\cdot e_{23}\cdot e_{31}\cdot q^{-1})\cdot (p\cdot e_{xy})^{-1}\]</span> where we grouped the parts that involve the change and do not involve it. So replacing <span class="math inline">\(e_{xy}\)</span> by <span class="math inline">\(e_{xz}\cdot e_{zy}\)</span> is definitionally equal to <span class="math display">\[A\cdot (p\cdot e_{xy})\cdot (q\cdot e_{12}\cdot e_{23}\cdot e_{31}\cdot q^{-1})\cdot (p\cdot e_{xy})^{-1}\cdot A^{-1}\]</span> where <span class="math inline">\(A\stackrel{\mathrm{def}}{=}p\cdot e_{xz}\cdot e_{zy}\cdot e_{xy}^{-1}\cdot p^{-1}\)</span> is the loop that circulates the difference between the paths. Said another way, we are making use of the observation that <span class="math inline">\(p_F\)</span> is related to <span class="math inline">\(p&#39;_F\)</span> by conjugating with the loop, based at <span class="math inline">\(m\)</span>, that goes around the discrepancy. If we add more such basic changes then we add additional conjugations.</p>
<p>If we change the basepoint <span class="math inline">\(m\)</span> to <span class="math inline">\(m&#39;\)</span> then we need to make a new choice, which is a path <span class="math inline">\(\pi:m&#39;=m\)</span>. This lengthens the path <span class="math inline">\(p_F\)</span> to the path <span class="math inline">\(\pi\cdot p_F\cdot \pi^{-1}\)</span>. This conjugation relates two different groups, the automorphism groups <span class="math inline">\(Tm=Tm\)</span> and <span class="math inline">\(Tm&#39;=Tm&#39;\)</span>. The two groups are not canonically identified because the identification relies on the choice of <span class="math inline">\(\pi\)</span>. If we change <span class="math inline">\(\pi\)</span> by a sequence of moves like we did with <span class="math inline">\(p_F\)</span> then again the holonomy at <span class="math inline">\(m&#39;\)</span> will change by a conjugation.</p>
<p>Finally we observe that for the triangle <span class="math inline">\(F\)</span>, an odd permutation that keeps the basepoint fixed is simply a traversal of the loop in the opposite direction, sending <span class="math inline">\(\ell_F\)</span> to <span class="math inline">\(\ell_{F^{-1}}\)</span>. ◻</p>
<figure id="fig:tail_move">
<img src="./dc8265541ed4b848af6958ab0ac895633eae0f45.svg" />
<figcaption>Two paths to the face, from <span class="math inline">\(x\)</span> to <span class="math inline">\(y\)</span> directly, or through <span class="math inline">\(z\)</span>.</figcaption>
</figure>
<div class="mycor">
<p><strong>Corollary 39</strong>. <em>In a bundle of mere circles <span class="math inline">\(T:\ensuremath{\mathbb{M}}\to\mathrm{EM}(\ensuremath{\mathbb{Z}},1)\)</span> the total holonomy is independent of the choice of paths <span class="math inline">\(p_{F_i}\)</span> and the basepoint <span class="math inline">\(m\)</span>. It is inverted if we switch orientations.</em></p>
</div>
<p><em>Proof.</em> This follows from the commutativity of <span class="math inline">\(S^1\)</span> and hence of the holonomy isomorphism groups <span class="math inline">\(Tm=Tm\)</span>. See <span class="citation" data-cites="buchholtz2023central"> (<a href="#ref-buchholtz2023central" role="doc-biblioref">Buchholtz <em>et al.</em>, 2023</a>)</span>, Example 3.8. ◻</p>
<div class="myex">
<p><strong>Example 40</strong>. <em>The total holonomy of <span class="math inline">\(T_1\)</span> on <span class="math inline">\(\ensuremath{\mathbb{O}}\)</span> (Definition <a href="#def:octahedron_holonomy" data-reference-type="ref" data-reference="def:octahedron_holonomy">24</a>) is <span class="math inline">\(\ensuremath{\text{id}}\)</span>, and the flatness structure is the path <span class="math inline">\(\ensuremath{\text{id}}=R^8\)</span> which is two full rotations of <span class="math inline">\(C_4\)</span>.</em></p>
</div>
<h2 data-number="6.2" id="total-index-of-a-vector-field"><span class="header-section-number">6.2</span> Total index of a vector field</h2>
<p>We defined the index on a face in Definition <a href="#def:index" data-reference-type="ref" data-reference="def:index">31</a>. We will extend this to a total index defined with a total enumeration of faces.</p>
<h2 data-number="6.3" id="the-main-theorem"><span class="header-section-number">6.3</span> The main theorem</h2>
<div class="mythm">
<p><strong>Theorem 41</strong>. <em>The total index is constant on <span class="math inline">\(\prod_{x:\ensuremath{\mathbb{M}}_1}T_1(x)\)</span>.</em></p>
</div>
<p>This appears to be a little less than what we have classically, which is:</p>
<ol>
<li><p>A definition of total curvature of a connection on the tangent bundle.</p></li>
<li><p>A definition of total index, without using the connection.</p></li>
<li><p>A definition of Euler characteristic.</p></li>
<li><p>A proof that total index is independent of the vector field.</p></li>
<li><p>A proof that total curvature is equal to total index.</p></li>
</ol>
<p>This collection of results provides enough redundancy to separately produce corollaries such as: total curvature is an integer; total curvature does not depend on the connection; a second proof that total index is independent of the vector field (since it is equal to total curvature, which does not so depend).</p>
<p>How much of this do we have?</p>
<h1 class="unnumbered" id="appendix">Appendix</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-bott_tu" class="csl-entry" role="listitem">
<span class="smallcaps">Bott</span>, R. &amp; <span class="smallcaps">Tu</span>, L.W. (1982) <em>Differential forms in algebraic topology</em>, Graduate texts in mathematics. Springer New York.
</div>
<div id="ref-buchholtz2023central" class="csl-entry" role="listitem">
<span class="smallcaps">Buchholtz</span>, U., <span class="smallcaps">Christensen</span>, J.D., <span class="smallcaps">Flaten</span>, J.G.T., &amp; <span class="smallcaps">Rijke</span>, E. (2023) <a href="https://arxiv.org/abs/2301.02636">Central h-spaces and banded types</a>.
</div>
<div id="ref-christensen_univalence" class="csl-entry" role="listitem">
<span class="smallcaps">Christensen</span>, D. (2015) A characterization of univalent fibrations.
</div>
<div id="ref-crane_connections" class="csl-entry" role="listitem">
<span class="smallcaps">Crane</span>, K. (2010) <a href="http://resolver.caltech.edu/CaltechTHESIS:05282010-102307125">Discrete connections for geometry processing</a> (Master’s thesis).
</div>
<div id="ref-crane_ddg" class="csl-entry" role="listitem">
<span class="smallcaps">Crane</span>, K., <span class="smallcaps">Goes</span>, F. de, <span class="smallcaps">Desbrun</span>, M., &amp; <span class="smallcaps">Schröder</span>, P. (2013) <a href="{https://www.cs.cmu.edu/~kmcrane/Projects/DDG/}">Digital geometry processing with discrete exterior calculus</a>. <em>ACM SIGGRAPH 2013 courses</em>, <em>SIGGRAPH ’13</em>. New York, NY, USA: ACM.
</div>
<div id="ref-hopf" class="csl-entry" role="listitem">
<span class="smallcaps">Hopf</span>, H. (1983) <a href="https://api.semanticscholar.org/CorpusID:117042538">Differential geometry in the large: Seminar lectures, new york university, 1946 and stanford university, 1956</a>.
</div>
<div id="ref-kirby_siebenmann" class="csl-entry" role="listitem">
<span class="smallcaps">Kirby</span>, R.C. &amp; <span class="smallcaps">Siebenmann</span>, L.C. (1977) <em>Foundational essays on topological manifolds, smoothings, and triangulations</em>, Annals of mathematics studies. Princeton University Press.
</div>
<div id="ref-myersgood" class="csl-entry" role="listitem">
<span class="smallcaps">Myers</span>, D.J. (2022) <a href="https://arxiv.org/abs/1908.08034">Good fibrations through the modal prism</a>.
</div>
<div id="ref-needham" class="csl-entry" role="listitem">
<span class="smallcaps">Needham</span>, T. (2021) <em><a href="https://books.google.com/books?id=Mc0QEAAAQBAJ">Visual differential geometry and forms: A mathematical drama in five acts</a></em>. Princeton University Press.
</div>
<div id="ref-dcct" class="csl-entry" role="listitem">
<span class="smallcaps">Schreiber</span>, U. (2013) <a href="https://arxiv.org/abs/1310.7930v1">Differential cohomology in a cohesive infinity-topos</a>.
</div>
<div id="ref-sco" class="csl-entry" role="listitem">
<span class="smallcaps">Scoccola</span>, L. (2020) <a href="https://doi.org/10.1017/s0960129520000146">Nilpotent types and fracture squares in homotopy type theory</a>. <em>Mathematical Structures in Computer Science</em>, <strong>30</strong>, 511–544.
</div>
<div id="ref-shulman_cohesion" class="csl-entry" role="listitem">
<span class="smallcaps">Shulman</span>, M. (2017) <a href="https://arxiv.org/abs/1509.07584">Brouwer’s fixed-point theorem in real-cohesive homotopy type theory</a>.
</div>
<div id="ref-talbott" class="csl-entry" role="listitem">
<span class="smallcaps">Talbott</span>, S. (1995) <em><a href="https://books.google.com/books?id=KcXaAAAAMAAJ">The future does not compute: Transcending the machines in our midst</a></em>. O’Reilly &amp; Associates.
</div>
<div id="ref-hottbook" class="csl-entry" role="listitem">
<span class="smallcaps">Univalent Foundations Program</span> (2013) <em>Homotopy type theory: Univalent foundations of mathematics</em>. Institute for Advanced Study: <a href="https://homotopytypetheory.org/book" class="uri">https://homotopytypetheory.org/book</a>.
</div>
<div id="ref-whitehead_triangulation" class="csl-entry" role="listitem">
<span class="smallcaps">Whitehead</span>, J.H.C. (1940) On <span><span class="math inline">\(C^1\)</span></span>-complexes. <em>Annals of Mathematics</em>, 809–824.
</div>
</div>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Not exactly. In Definition <a href="#def:connection" data-reference-type="ref" data-reference="def:connection">19</a> the flatness structure is a homotopy from a hub point to the polygonal boundary. But this is equivalent.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
